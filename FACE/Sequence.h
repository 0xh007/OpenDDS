#ifndef OPENDDS_FACE_SEQUENCE_HEADER
#define OPENDDS_FACE_SEQUENCE_HEADER

#include "FACE/types.hpp"
#include "FACE/StringManager.h"

#include "dds/DCPS/SafetyProfilePool.h"

#include <algorithm>
#include <utility>
#include <cstddef>

namespace OpenDDS {
namespace FaceTypes {

  typedef FACE::UnsignedLong seq_size_type;
  typedef FACE::Boolean seq_flag_type;

  template <seq_size_type N>
  struct Bounded {
    static const seq_size_type Bounds = N;
  };

  struct Unbounded {
    static const seq_size_type Bounds = INT_MAX;
  };

  template <typename T, typename Bounds, typename EltPolicy>
  struct AllocPolicy;

  template <typename T, seq_size_type N, typename EltPolicy>
  struct AllocPolicy<T, Bounded<N>, EltPolicy> {
    static T* allocbuf();
    seq_size_type maximum() const { return N; }
    seq_size_type max_size() const { return N; }
  protected:
    explicit AllocPolicy(seq_size_type = N) {}
    T* allocate(seq_size_type = N) { return allocbuf(); }
    void swap(AllocPolicy&) throw() {}
  };

  template <typename T, typename EltPolicy>
  struct AllocPolicy<T, Unbounded, EltPolicy> {
    static T* allocbuf(seq_size_type n);
    seq_size_type maximum() const { return maximum_; }
    seq_size_type max_size() const { return Unbounded::Bounds; }
  protected:
    explicit AllocPolicy(seq_size_type n = 0) : maximum_(n) {}
    T* allocate(seq_size_type request = 0)
    {
      return allocbuf(request ? request : maximum_);
    }
    void swap(AllocPolicy& rhs) throw() { std::swap(maximum_, rhs.maximum_); }
    seq_size_type maximum_;
  };

  /// Element Policy for sequence elements that are IDL "fixed-length" types.
  /// These types don't need initialization or destruction of elements in their
  /// allocbuf()/freebuf() functions.
  /// @tparam T element type of the sequence
  template <typename T>
  struct DefaultEltPolicy {
    typedef T& Element;
    typedef const T& ConstElement;
    typedef T ConstRawElement;
    static const seq_size_type extra = 0;
    static T& make_element(T& elt, seq_flag_type) { return elt; }
    static void init(T*, seq_size_type, seq_flag_type) {}
    static void copy_n(const T* input, seq_size_type n, T* output);
    static T* destroy(T* buffer, seq_size_type) { return buffer; }
  };

  /// Element Policy for sequences of strings.
  /// @tparam CharT FACE::Char or FACE::WChar
  template <typename CharT>
  struct StringEltPolicy {

    /// Indexing a non-const string sequence yields and object of this class.
    /// This allows string memory management duing assignment.
    struct Element {
      Element(CharT*& element, seq_flag_type release)
        : element_(element), release_(release) {}

      Element(const Element& elt)
        : element_(elt.element_), release_(elt.release_) {}

      Element& operator=(const CharT* rhs)
      {
        String_var<CharT> tmp(rhs);
        return move_from(tmp);
      }

      Element& operator=(CharT* rhs)
      {
        String_var<CharT> tmp(rhs);
        return move_from(tmp);
      }

      Element& operator=(const String_var<CharT>& rhs)
      {
        String_var<CharT> tmp(rhs);
        return move_from(tmp);
      }

      Element& operator=(const StringManager<CharT>& rhs)
      {
        String_var<CharT> tmp(rhs);
        return move_from(tmp);
      }

      operator const CharT*() const { return element_; }
      const CharT* in() const { return element_; }
      CharT*& inout() { return element_; }

      String_out<CharT> out() const
      {
        if (release_) StringTraits<CharT>::free(element_);
        return element_;
      }

      CharT* _retn()
      {
        CharT* const tmp = element_;
        element_ = StringTraits<CharT>::empty();
        return tmp;
      }

    private:
      Element& move_from(String_var<CharT>& rhs)
      {
        if (release_) StringTraits<CharT>::free(element_);
        element_ = rhs._retn();
        return *this;
      }

      CharT*& element_;
      seq_flag_type release_;
    };

    static Element make_element(CharT*& elt, seq_flag_type release)
    {
      return Element(elt, release);
    }

    typedef const CharT* ConstElement;
    typedef const CharT* ConstRawElement;
    static const seq_size_type extra = 1;
    static void init(CharT** buffer, seq_size_type n, seq_flag_type use_cookie);
    static void copy_n(const CharT* const* in, seq_size_type n, CharT** out);
    static CharT** destroy(CharT** buffer, seq_size_type n);
  };

  /// Generic base class for all IDL-defined sequences accepted by opendds_idl.
  /// Derived classes (generated by opendds_idl) need to provide the following
  /// methods to be compliant with the IDL-to-C++ specification:
  /// If bounded:
  /// - Constructors: default, copy, 3-arg
  /// - 3-arg replace() that calls this class's replace_i()
  /// If unbounded:
  /// - Constructors: default, copy, 1-arg (maximum), 4-arg
  /// - 4-arg replace() that calls this class's replace_i()
  /// Both bounded and unbounded:
  /// - Copy assignment
  /// - non-member swap(), while not in spec this is useful for copy assignment
  /// @tparam T element type of the sequence
  /// @tparam Bounds either Bounded<N> or Unbounded
  /// @tparam Elts element handling policy
  template <typename T, typename Bounds, typename Elts = DefaultEltPolicy<T> >
  class Sequence : public AllocPolicy<T, Bounds, Elts> {
  public:
    typedef seq_size_type size_type;  // from std C++ Container concept
    typedef seq_size_type _size_type; // from IDL-to-C++ specification

  protected:
    explicit Sequence(size_type maximum = 0, size_type length = 0,
                      T* data = 0, seq_flag_type release = false);
    Sequence(const Sequence& seq);
    ~Sequence();
    Sequence& operator=(const Sequence& seq);

    void swap(Sequence& rhs) throw();

    void replace_i(size_type maximum, size_type length,
                   T* data, seq_flag_type release);
  public:
    using AllocPolicy<T, Bounds, Elts>::maximum;
    void length(size_type len);
    size_type length() const { return length_; }

    typedef typename Elts::Element Element;
    typedef typename Elts::ConstElement ConstElement;
    typedef typename Elts::ConstRawElement ConstRawElement;

    ConstElement operator[](size_type idx) const;
    Element operator[](size_type idx);

    seq_flag_type release() const { return release_; }

    T* get_buffer(seq_flag_type orphan = false);
    const ConstRawElement* get_buffer() const;

    // allocbuf() inherited from AllocPolicy
    static void freebuf(T* data);


    // C++ standard library container compatibility:

    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef T* iterator;
    typedef const T* const_iterator;
    typedef std::ptrdiff_t difference_type;

    const T* begin() const { return buffer_; }
    T* begin() { return buffer_; }

    const T* end() const { return buffer_ + length_; }
    T* end() { return buffer_ + length_; }

    bool operator==(const Sequence& rhs) const;
    bool operator!=(const Sequence& rhs) const;

    size_type size() const { return length_; }
    // max_size() inherited from AllocPolicy
    bool empty() const { return length_; }

  private:
    using AllocPolicy<T, Bounds, Elts>::allocate;
    void lazy_alloc();

    size_type length_;
    seq_flag_type release_;
    T* buffer_;
  };


  template <typename T, seq_size_type N, typename EltPolicy>
  inline T* AllocPolicy<T, Bounded<N>, EltPolicy>::allocbuf()
  {
    void* const raw =
      DCPS::SafetyProfilePool::instance()->malloc(N * sizeof(T));
    T* const mem = static_cast<T*>(raw);
    EltPolicy::init(mem, N, false);
    return mem;
  }

  template <typename T, typename EltPolicy>
  inline T* AllocPolicy<T, Unbounded, EltPolicy>::allocbuf(seq_size_type n)
  {
    const size_t bytes = (n + EltPolicy::extra) * sizeof(T);
    void* const raw = DCPS::SafetyProfilePool::instance()->malloc(bytes);
    T* const mem = static_cast<T*>(raw);
    EltPolicy::init(mem, n, true);
    return mem + EltPolicy::extra;
  }

  template <typename T>
  inline void DefaultEltPolicy<T>::copy_n(const T* in, seq_size_type n, T* out)
  {
    for (seq_size_type i = 0; i < n; ++i) {
      out[i] = in[i];
    }
  }

  template <typename CharT>
  inline void StringEltPolicy<CharT>::init(CharT** buffer, seq_size_type n,
                                           seq_flag_type use_cookie)
  {
    for (seq_size_type i = use_cookie; i < n + use_cookie; ++i) {
      buffer[i] = StringTraits<CharT>::empty();
    }
    if (use_cookie) {
      *reinterpret_cast<seq_size_type*>(buffer[0]) = n;
    }
  }

  template <typename CharT>
  inline void StringEltPolicy<CharT>::copy_n(const CharT* const* in,
                                             seq_size_type n, CharT** out)
  {
    for (seq_size_type i = 0; i < n; ++i) {
      StringTraits<CharT>::free(out[i]);
      out[i] = StringTraits<CharT>::dup(in[i]);
    }
  }

  template <typename CharT>
  inline CharT** StringEltPolicy<CharT>::destroy(CharT** buffer,
                                                 seq_size_type n_or_int_max)
  {
    seq_size_type n = n_or_int_max;
    CharT** allocated = buffer;

    if (n_or_int_max == INT_MAX) {
      allocated = buffer - 1;
      n = *reinterpret_cast<seq_size_type*>(*allocated);
    }

    for (seq_size_type i = 0; i < n; ++i) {
      StringTraits<CharT>::free(buffer[i]);
    }

    return allocated;
  }

  template <typename T, typename Bounds, typename Elts>
  inline Sequence<T, Bounds, Elts>::Sequence(size_type maximum,
                                             size_type length,
                                             T* data, seq_flag_type release)
    : AllocPolicy<T, Bounds, Elts>(maximum)
    , length_(length)
    , release_(release)
    , buffer_(data)
  {
  }

  template <typename T, typename Bounds, typename Elts>
  inline Sequence<T, Bounds, Elts>::Sequence(const Sequence& seq)
    : AllocPolicy<T, Bounds, Elts>(seq.maximum())
    , length_(seq.length())
    , release_(true)
    , buffer_(this->allocate())
  {
    Elts::copy_n(seq.buffer_, length_, buffer_);
  }

  template <typename T, typename Bounds, typename Elts>
  inline Sequence<T, Bounds, Elts>::~Sequence()
  {
    if (release_) {
      freebuf(buffer_);
    }
  }

  template <typename T, typename Bounds, typename Elts>
  inline Sequence<T, Bounds, Elts>&
  Sequence<T, Bounds, Elts>::operator=(const Sequence& seq)
  {
    Sequence cpy(seq);
    swap(cpy);
    return *this;
  }

  template <typename T, typename Bounds, typename Elts>
  inline void Sequence<T, Bounds, Elts>::swap(Sequence& rhs) throw()
  {
    AllocPolicy<T, Bounds, Elts>::swap(rhs);
    std::swap(length_, rhs.length_);
    std::swap(release_, rhs.release_);
    std::swap(buffer_, rhs.buffer_);
  }

  template <typename T, typename Bounds, typename Elts>
  inline void Sequence<T, Bounds, Elts>::replace_i(size_type maximum,
                                                   size_type length, T* data,
                                                   seq_flag_type release)
  {
    Sequence tmp(maximum, length, data, release);
    swap(tmp);
  }

  template <typename T, typename Bounds, typename Elts>
  inline void Sequence<T, Bounds, Elts>::lazy_alloc()
  {
    if (!buffer_) {
      buffer_ = allocate();
      release_ = true;
    }
  }

  template <typename T, typename Bounds, typename Elts>
  inline void Sequence<T, Bounds, Elts>::length(size_type len)
  {
    if (len <= maximum()) {
      if (len && !buffer_) {
        lazy_alloc();
      }
      else if (release_ && len < length_) {
        //TODO
      }
      length_ = len;
      return;
    }

    Sequence tmp(len, len, allocate(len), true);
    //TODO: opt?
    Elts::copy_n(buffer_, length_, tmp.buffer_);
    swap(tmp);
  }

  template <typename T, typename Bounds, typename Elts>
  inline typename Sequence<T, Bounds, Elts>::ConstElement
  Sequence<T, Bounds, Elts>::operator[](size_type idx) const
  {
    return buffer_[idx];
  }

  template <typename T, typename Bounds, typename Elts>
  inline typename Sequence<T, Bounds, Elts>::Element
  Sequence<T, Bounds, Elts>::operator[](size_type idx)
  {
    return Elts::make_element(buffer_[idx], release_);
  }

  template <typename T, typename Bounds, typename Elts>
  inline T* Sequence<T, Bounds, Elts>::get_buffer(seq_flag_type orphan)
  {
    if (orphan && !release_) {
      return 0;
    }

    lazy_alloc();

    if (orphan) {
      Sequence tmp;
      swap(tmp);
      tmp.release_ = false;
      return tmp.buffer_;
    }

    return buffer_;
  }

  template <typename T, typename Bounds, typename Elts>
  inline const typename Sequence<T, Bounds, Elts>::ConstRawElement*
  Sequence<T, Bounds, Elts>::get_buffer() const
  {
    lazy_alloc();
    return buffer_;
  }

  template <typename T, typename Bounds, typename Elts>
  inline void Sequence<T, Bounds, Elts>::freebuf(T* data)
  {
    if (!data) return;
    T* const allocated = Elts::destroy(data, Bounds::Bounds);
    DCPS::SafetyProfilePool::instance()->free(allocated);
  }

  template <typename T, typename Bounds, typename Elts>
  inline bool Sequence<T, Bounds, Elts>::operator==(const Sequence& rhs) const
  {
    const size_type sz = size();
    if (sz != rhs.size()) {
      return false;
    }
    for (size_type i = 0; i < sz; ++i) {
      if ((*this)[i] != rhs[i]) {
        return false;
      }
    }
    return true;
  }

  template <typename T, typename Bounds, typename Elts>
  inline bool Sequence<T, Bounds, Elts>::operator!=(const Sequence& rhs) const
  {
    return !(*this == rhs);
  }


  // -----

  void testing()
  {
    struct S1 : Sequence<int, Unbounded> {} s1;
    struct S2 : Sequence<int, Bounded<5> > {} s2;
    s1.maximum();
    s2.maximum();
    s1.allocbuf(3);
    s2.allocbuf();

    struct SS : Sequence<char*, Unbounded, StringEltPolicy<char> > {} ss;
    ss.length(2);
    ss[0] = "foo";
    ss[1] = "bar";
    ss[0] = "baz"; // frees "foo" before copying "baz"
  }
}
}

int main() { OpenDDS::FaceTypes::testing(); return 0; }
#endif
