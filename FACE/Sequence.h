#ifndef OPENDDS_FACE_SEQUENCE_HEADER
#define OPENDDS_FACE_SEQUENCE_HEADER

#include "FACE/types.hpp"
#include <limits>
#include <cstddef>

namespace OpenDDS {
namespace FaceTypes {

  typedef FACE::UnsignedLong seq_size_type;

  template <seq_size_type N>
  struct Bounded {};

  struct Unbounded {};

  template <typename T, typename Bounds>
  struct AllocPolicy;

  template <typename T, seq_size_type N>
  struct AllocPolicy<T, Bounded<N> > {
    static T* allocbuf();
    seq_size_type maximum() const { return N; }
    seq_size_type max_size() const { return N; }
  protected:
    explicit AllocPolicy(seq_size_type = 0) {}
  };

  template <typename T>
  struct AllocPolicy<T, Unbounded> {
    static T* allocbuf(seq_size_type n);
    seq_size_type maximum() const { return maximum_; }
    seq_size_type max_size() const {
      return std::numeric_limits<seq_size_type>::max();
    }
  protected:
    explicit AllocPolicy(seq_size_type n = 0) : maximum_(n) {}
    seq_size_type maximum_;
  };

  /// Generic base class for all IDL-defined sequences accepted by opendds_idl.
  /// Derived classes (generated by opendds_idl) need to provide the following
  /// methods to be compliant with the IDL-to-C++ specification:
  /// If bounded:
  /// - Constructors: default, copy, 3-arg
  /// - 3-arg replace() that calls this class's replace_i()
  /// If unbounded:
  /// - Constructors: default, copy, 4-arg
  /// - 4-arg replace() that calls this class's replace_i()
  /// Both bounded and unbounded:
  /// - Copy assignment
  /// - non-member swap(), while not in spec this is useful for copy assignment
  /// @tparam T element type of the sequence
  /// @tparam Bounds either Bounded<N> or Unbounded
  template <typename T, typename Bounds>//, typename ElementPolicy>
  class Sequence : public AllocPolicy<T, Bounds> {
  public:
    typedef seq_size_type size_type;
    typedef seq_size_type _size_type; // from IDL-to-C++ specification
    typedef FACE::Boolean flag_type;

  protected:
    explicit Sequence(size_type maximum = 0, size_type length = 0,
                      T* data = 0, flag_type release = false);
    Sequence(const Sequence& seq);
    ~Sequence();
    Sequence& operator=(const Sequence& seq);

    void swap(Sequence& rhs);

    void replace_i(size_type maximum, size_type length,
                   T* data, flag_type release);
  public:
    // maximum() inherited from AllocPolicy

    void length(size_type len);
    size_type length() const { return length_; }

    //TODO:
    typedef T Element;

    const Element& operator[](size_type idx) const;
    Element& operator[](size_type idx);

    flag_type release() const { return release_; }

    T* get_buffer(flag_type orphan = false);
    const T* get_buffer() const;

    // allocbuf() inherited from AllocPolicy

    static void freebuf(T* data);


    // C++ standard library container compatibility:

    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef T* iterator;
    typedef const T* const_iterator;
    typedef std::ptrdiff_t difference_type;

    const T* begin() const { return buffer_; }
    T* begin() { return buffer_; }

    const T* end() const { return buffer_ + length_; }
    T* end() { return buffer_ + length_; }

    bool operator==(const Sequence& rhs) const;
    bool operator!=(const Sequence& rhs) const;

    size_type size() const { return length_; }
    // max_size() inherited from AllocPolicy
    bool empty() const { return length_; }

  private:
    size_type length_;
    flag_type release_;
    T* buffer_;
  };


  template <typename T, seq_size_type N>
  inline T* AllocPolicy<T, Bounded<N> >::allocbuf()
  {
    return new T[N];  //TODO: allocators, initialize strings
  }

  template <typename T>
  inline T* AllocPolicy<T, Unbounded>::allocbuf(seq_size_type n)
  {
    return new T[n];  //TODO: allocators, initialize strings
  }

  template <typename T, typename Bounds>
  inline Sequence<T, Bounds>::Sequence(size_type maximum, size_type length,
                                       T* data, flag_type release)
    : AllocPolicy<T, Bounds>(maximum)
    , length_(length)
    , release_(release)
    , buffer_(data)
  { //TODO: init
  }

  template <typename T, typename Bounds>
  inline Sequence<T, Bounds>::Sequence(const Sequence& seq)
    : AllocPolicy<T, Bounds>(seq.maximum())
    , length_(seq.length())
    , release_(true)
    , buffer_(0)
  { //TODO: init
  }

  template <typename T, typename Bounds>
  inline Sequence<T, Bounds>::~Sequence()
  { //TODO
  }

  template <typename T, typename Bounds> inline
  Sequence<T, Bounds>& Sequence<T, Bounds>::operator=(const Sequence& seq)
  {
    Sequence cpy(seq);
    swap(cpy);
    return *this;
  }

  template <typename T, typename Bounds>
  inline void Sequence<T, Bounds>::swap(Sequence& rhs)
  { //TODO
  }

  template <typename T, typename Bounds>
  inline void Sequence<T, Bounds>::replace_i(size_type maximum,
                                             size_type length, T* data,
                                             flag_type release)
  { // TODO
  }

  template <typename T, typename Bounds>
  inline void Sequence<T, Bounds>::length(size_type len)
  { //TODO
  }

  template <typename T, typename Bounds>
  inline const T& Sequence<T, Bounds>::operator[](size_type idx) const
  {
    return buffer_[idx];
  }

  template <typename T, typename Bounds>
  inline T& Sequence<T, Bounds>::operator[](size_type idx)
  {
    return buffer_[idx];
  }

  template <typename T, typename Bounds>
  inline T* Sequence<T, Bounds>::get_buffer(flag_type orphan)
  { //TODO
    return buffer_;
  }

  template <typename T, typename Bounds>
  inline const T* Sequence<T, Bounds>::get_buffer() const
  {
    return buffer_;
  }

  template <typename T, typename Bounds>
  inline void Sequence<T, Bounds>::freebuf(T* data)
  { //TODO
  }

  template <typename T, typename Bounds>
  inline bool Sequence<T, Bounds>::operator==(const Sequence& rhs) const
  { //TODO
    return false;
  }

  template <typename T, typename Bounds>
  inline bool Sequence<T, Bounds>::operator!=(const Sequence& rhs) const
  {
    return !(*this == rhs); //TODO: opt?
  }


  // -----

  void testing()
  {
    struct S1 : Sequence<int, Unbounded> {} s1;
    struct S2 : Sequence<int, Bounded<5> > {} s2;

    s1.maximum();
    s2.maximum();
    s1.allocbuf(3);
    s2.allocbuf();
  }
}
}

int main() { OpenDDS::FaceTypes::testing(); return 0; }
#endif
