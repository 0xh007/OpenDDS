<!-- TODO: Reorder for chronological order of operations -->
# OpenDDS and Android

**How to build OpenDDS for Android and incorperate OpenDDS into Android apps.**

**WARNING: Android support is experimental and not fully supported!**

**This guide assumes the use of a Unix-like enviroment and Android Studio**

## Building OpenDDS for Android

Building OpenDDS for Android requires the [Android Native Development Kit
(NDK)](https://developer.android.com/ndk/). As Android targets multiple
architectures and has many versions, an architecture and minimum API version to
use will have to be decided. As of writing [this page lists Android version
numbers and their corresponding API
versions](https://source.android.com/setup/start/build-numbers). You will have
to do a separate build for each architecture if you want to build OpenDDS for
multiple architectures.

The following table describes some of the variables that are referenced in this
guide. You don't have to actually set and use these, they are for shorthand
here.

| Variable     | Description                                      |
| ------------ | ------------------------------------------------ |
| `$DDS_ROOT`  | OpenDDS Source                                   |
| `$NDK`       | The Android NDK                                  |
| `$TOOLCHAIN` | The Generated Toolchain                          |
| `$SDK`       | The Android SDK (By default `$HOME/Android/Sdk`) |
| `$STUDIO`    | Android Studio Location                          |
| `$JDK`       | The Java SDK                                     |

**NDK r18 or higher is required to build OpenDDS for Android.** You can download it
separately from android.com or using the SDK Manager that comes with Android
Studio. If you download the NDK using the SDK Manager, this is located in
`$SDK/ndk-bundle`.

A standalone toolchain is required and can be generated by using
`$NDK/build/tools/make_standalone_toolchain.py`.
For example, to create a toolchain for 32-bit ARM Android 7.0 "Nougat" and
later:

```
$NDK/build/tools/make_standalone_toolchain.py --arch arm --api 24 --install-dir $TOOLCHAIN
```

Once a toolchain is obtained, OpenDDS can be configured to cross compile for
Android by passing `--target=android` and `--macros=ANDROID_ABI=<ARCH>` to the
OpenDDS configure script. The `--arch` argument for
`make_standalone_toolchain.py` and `--macros=ANDROID_ABI=<ARCH>` argument for
the configure script must match according to this table:

| `--arch` | `ANDROID_ABI`           | Description                                  |
| -------- | ----------------------- | -------------------------------------------- |
| `arm`    | `armeabi-v7a`           | 32-bit ARM                                   |
| `arm`    | `armeabi-v7a-with-neon` | `armeabi-v7a` with NEON extensions enabled [1](#footnote-1) |
| `arm64`  | `arm64-v8a`             | 64-bit ARM, Sometimes referred to as aarch64 |
| `x86`    | `x86`                   | 32-bit x86                                   |
| `x86_64` | `x86_64`                | 64-bit x86                                   |

For example, to build OpenDDS with the toolchain generated in the previous
example, we can use `armeabi-v7a` [1](#footnote-1).

```
cd $DDS_ROOT
./configure --no-tests --target=android --macros=ANDROID_ABI=armeabi-v7a
PATH=$PATH:$TOOLCHAIN/bin make # Pass -j/--jobs with an appropriate value or this'll take a while...
```

If building for more than one architecture, which will be necessary to cover
the largest number of Android devices possible, it might make sense to build a
static build OpenDDS separately, which then can be passed using `--host-tools`
to the configure script.

If you want to just want the mimunimum needed for host OpenDDS tools, these are
the required binaries.

 * `OpenDDS/bin/opendds_idl`
 * `OpenDDS/bin/idl2jni` (if using the OpenDDS Java API)
 * `ACE_TAO/bin/ace_gperf`
 * `ACE_TAO/bin/tao_idl`

<!-- TODO: Finish -->

### OpenDDS's Optional Dependencies

#### Java

To use OpenDDS in the traditional Android development language, Java, you will
need to build the Java bindings when building OpenDDS. See
[../java/README]([../java/README) for details. For Android you can use the JDK
provided with Android Studio, so `JDK=$STUDIO/jre`. Pass `--java=$JDK` to the
OpenDDS configure script.

#### OpenSSL

OpenSSL is required for OpenDDS Security. Fortunately it comes with a
configuration for Android, please read `NOTES.ANDROID` that comes with
OpenSSL's source code for how to build OpenSSL for Android.

Android preloads the system SSL library (either OpenSSL or BoringSSL) for the
Java Android API, so OpenSSL **MUST** be statically linked to the OpenDDS
security library. The static libraries will used if the shared libraries are
not found. This can be accomplished by either disabling the generation of the
shared libraries by passing `no-shared` to OpenSSL's `Configure` script or just
deleting the `so` files after building OpenSSL.

#### Xerces

Xerces is also required for OpenDDS Security. It does not support Android
specifically, but it comes with a CMake build script that can be paired with
the Android NDK's CMake cross compile file.

Xerces requires a supported "transcoder" library. For API levels greater than
or equal to 28 one of these is included with Android, GNU libiconv. Before 28
any of the transcoders supported by Xerces would work theoretically but GNU
libiconv was the one tested.

## Cross-Compiling IDL Libraries

Like all OpenDDS applications, you will need to use type support libraries to
use most of OpenDDS's functionality.

<!-- TODO -->

## Using OpenDDS in a Android App

After building OpenDDS and generating the IDL libraries, you will need to set
up an app to be able to use OpenDDS.

### Adding the OpenDDS Libraries to the App

In your app's `build.gradle` (*NOT THE ONE OF THE SAME NAME IN THE ROOT OF THE
PROJECT*) add this to the `android` section:

```Gradle
    sourceSets {
        main {
            jniLibs.srcDirs 'native_libs'
        }
    }
```

`native_libs` is not a required name, but it needs to contain subdirectories
named after the `ANDROID_ABI` of the native libraries it contains.

<!-- TODO -->

### Network Permissions and Availability

In `AndroidManifest.xml` you will need to add the network permissions if they
are not already there:

```XML
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
```

Failure to do so will result in ACE failing to access any sockets and OpenDDS
will not be able to function.

In addition to this if no networks are active when OpenDDS is initialized, then
the result will similar. It will be up to the app developer to assess
network availability before initializing OpenDDS. On Android this can be done
using the
[ConnectivityManager](https://developer.android.com/reference/android/net/ConnectivityManager),
but the exact method for doing so will depend on the API level and the needs of
the app.

<!-- TODO: Changes in Networks or Loss of Network? -->

### OpenDDS Configuration Files

OpenDDS can use several types of files: a main configuration file, security
configuration files, and security certificate files, among others. On
traditional platforms, distributing and reading these files is usually not an
issue at all. On Android however, an app has no traditional files of it's own
out of the box, so you can't give OpenDDS a path to a file you want to
distribute with the app without preparing beforehand.

If you already have a preferred way to include files in your app, then that
will work as long as you can give OpenDDS the path to the files.

Android can open a file stream for resource and asset files. Ideally OpenDDS
would be able to accept these streams, but it doesn't. One solution to this is
reading the streams into memory and then writing them to files in the app's
private directory. This example is using assets, but resources will also work
with some slight modifications.

```Java
// ...
    private String copyAsset(String asset_path) {
        File new_file = new File(getFilesDir(), asset_path);
        final String full_path = new_file.getAbsolutePath();
        try {
            InputStream in = getAssets().open(asset_path, AssetManager.ACCESS_BUFFER);
            byte[] buffer = new byte[in.available()];
            in.read(buffer);
            in.close();
            FileOutputStream out = new FileOutputStream(new_file);
            out.write(buffer);
            out.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return full_path;
    }
// ...

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        // ...

        final String config_file = copyAsset("opendds_config.ini");
        String[] args = new String[] {"-DCPSConfigFile", config_file};
        StringSeqHolder argsHolder = new StringSeqHolder(args);
        dpf = TheParticipantFactory.WithArgs(argsHolder);
        // ...
    }
// ...
```

This example works but in production code the error handling should be improved
and integrated with the app's initialization. Rewriting the file every time is
not ideal, but OpenDDS's files are small and this method insures the files are
up-to-date.

### Multithreading

When using a `DataReaderListener`, the callbacks will be using a ACE reactor
worker thread, which can't make changes to the Android GUI directly because
it's not the main thread. To have these callbacks affect changes in the Android
GUI, use something like
[`android.os.Handler`](https://developer.android.com/reference/android/os/Handler):

```Java
// ...

import android.os.Handler;

// ...

public class DataReaderListenerImpl extends DDS._DataReaderListenerLocalBase {

    private MainActivity context;

    public DataReaderListenerImpl(MainActivity context) {
        super();
        this.context = context;
    }

    public synchronized void on_data_available(DDS.DataReader reader) {
        StatusDataReader mdr = StatusDataReaderHelper.narrow(reader);
        if (mdr == null) {
            return;
        }
        StatusHolder mh = new StatusHolder(new Status());
        SampleInfoHolder sih = new SampleInfoHolder(new SampleInfo(0, 0, 0,
                new DDS.Time_t(), 0, 0, 0, 0, 0, 0, 0, false, 0));
        int status = mdr.take_next_sample(mh, sih);

        if (status == RETCODE_OK.value) {

            // ...

            Handler handler = new Handler(context.getMainLooper());
            handler.post(new Runnable() {
                @Override
                public void run() {
                    context.tryToUpdateThermostat(thermostat_status);
                }
            });
        }
    }
}
```

### Android Activity Lifecycle

The [Android Activity
Lifecycle](https://developer.android.com/guide/components/activities/activity-lifecycle)
is something that affects all Android Apps. In the case of OpenDDS, the
interaction gets more complicated because of the intersection of the similar,
but distinct process lifecycle. The process hosts the activity, but isn't
guaranteed to be kept alive after `onStop()` is called. What makes this worse
for NDK applications is that there doesn't seem to be a way to be warned of
this. For most applications of OpenDDS, this isn't a serious issue but it's not
ideal. The authors recommends creating participants created in `onStart()` as
might be expected, but deleting in `onStop()`, so that they may be created
again in `onStart()`. The `DomainParticpantFactory` can be retrieved either in
`onStart()` or more perhaps appropriately in
[`Application.onStart()`](https://developer.android.com/reference/android/app/Application),
given the singleton nature of both.

<!-- 
TODO
### Using C++

-->
### Using Java

In your app's `build.gradle` (*NOT THE ONE OF THE SAME NAME IN THE ROOT OF THE
PROJECT*) add this to the `dependencies` section if not already there:

```Gradle
    implementation fileTree(include: ['*.jar'], dir: 'libs')
```

<!-- TODO -->

## Footnotes

<a id="footnote-1"/>
1. The choice to support NEON or not is beyond the scope of this guide. See
   ["NEON Support"](https://developer.android.com/ndk/guides/cpu-arm-neon) for
   more information.
